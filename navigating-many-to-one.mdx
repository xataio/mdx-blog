---
title: 'Managing many-to-one and one-to-many database relations'
description: 'Addressing the n+1 problem and navigating one-to-many relationships with Xata's new approach.'
image:
  src: 'https://raw.githubusercontent.com/xataio/mdx-blog/main/images/csv-import-export-cover.jpg'
  alt: 'image'
ogImage: 'https://raw.githubusercontent.com/xataio/mdx-blog/main/images/csv-import-export-cover-og.jpg
author: Alejandro Martínez Vieites
date: 09-01-2023
published: true
slug: navigating-many-to-one
---

As part of our ongoing [launch week](/blog/launch-week-august-2023), we're looking at APIs and their intricate relationships. Today, we're introducing a new syntax that simplifies navigating these relationships. While Xata already provides a great way to retrieve related data using [link columns](/docs/concepts/data-model#link) for the _many-to-one_ relationship, we're addressing the challenge of navigating the reverse [relationship](https://xata.io/docs/concepts/data-model#links-and-relations) (_one-to-many_). This new approach improves efficiency and helps avoid the _n + 1 problem_.

Let's consider a basic schema. Within our schema, there's a _posts_ table containing certain information and establishing a connection to the corresponding author. This author-related data belongs in the _users_ table.

![](image/many-to-one-relationships.png)

When querying the _posts_ table we are able to retrieve the title, likes, and the author’s name (and any other fields present in the _users_ table):

```json
// Request
POST /db/blogs:main/tables/posts/query
{
  "columns": ["*","author.*"]
}

// Response (xata fields have been omitted for clarity)
{
    "records": [
        {
            "author": {
                "id": "rec_cie05krjtojbm41fv2q0",
                "name": "Tudor Golubenco"
            },
            "id": "rec_cie05srjtojbm41fv2t0",
            "likes": 13,
            "title": "Postgres schema changes are still a PITA"
        },
        {
            "author": {
                "id": "rec_cie05krjtojbm41fv2q0",
                "name": "Tudor Golubenco"
            },
            "id": "rec_cie05v3jtojbm41fv2tg",
            "likes": 15,
            "title": "On the performance impact of REPLICA IDENTITY FULL in Postgres"
        },
        {
            "author": {
                "id": "rec_cie05ljjtojbm41fv2qg",
                "name": "Joan Edwards"
            },
            "id": "rec_cie060jjtojbm41fv2u0",
            "likes": 5,
            "title": "Introducing the new Xata regions: Sydney & Frankfurt"
        },
        {
            "author": {
                "id": "rec_cie05krjtojbm41fv2q0",
                "name": "Tudor Golubenco"
            },
            "id": "rec_cii1kajjtoj0t82ae3ag",
            "likes": 6,
            "title": "Semantic or keyword search for finding ChatGPT context. Who searched it better?"
        },
        {
            "author": {
                "id": "rec_cii1ki3jtoj0t82ae3b0",
                "name": "Alex Francoeur"
            },
            "id": "rec_cii1kjjjtoj0t82ae3bg",
            "likes": 9,
            "title": "The next era of databases are serverless, adaptive, and collaborative"
        },
        {
            "author": {
                "id": "rec_cii1ki3jtoj0t82ae3b0",
                "name": "Alex Francoeur"
            },
            "id": "rec_cii1kpbjtoj0t82ae3c0",
            "likes": 8,
            "title": "End-to-end preview deployment workflows with Xata and Vercel"
        },
        {
            "author": {
                "id": "rec_cii1ki3jtoj0t82ae3b0",
                "name": "Alex Francoeur"
            },
            "id": "rec_cii1l1rjtoj0t82ae3cg",
            "likes": 20,
            "title": "Modern database workflows with GitHub, Vercel, Netlify, and Xata"
        }
    ]
}
```

## The N + 1 problem

What if we wanted to list the authors and their posts? You would need to query the _users_ table in order to retrieve all authors:

```json
// Request
POST /db/blogs:main/tables/users/query
{
  "columns": ["*"]
}

// Response (Xata fields have been omitted for clarity)
{
    "records": [
        {
            "id": "rec_cie05krjtojbm41fv2q0",
            "name": "Tudor Golubenco"
        },
        {
            "id": "rec_cie05ljjtojbm41fv2qg",
            "name": "Joan Edwards"
        },
        {
            "id": "rec_cii1ki3jtoj0t82ae3b0",
            "name": "Alex Francoeur"
        }
    ]
}
```

And then, for each user that has been returned, make a separate request in the _posts_ table to retrieve the posts from each author, similar to:

```json
// Request
POST /db/blogs:main/tables/posts/query
{
  "columns": ["*"],
  "filter": {
      "author": "rec_cie05krjtojbm41fv2q0"
  }
}

// Response (Xata fields have been omitted for clarity)
{
    "records": [
        {
            "author": {
                "id": "rec_cie05krjtojbm41fv2q0"
            },
            "id": "rec_cie05srjtojbm41fv2t0",
            "likes": 13,
            "title": "Postgres schema changes are still a PITA"
        },
        {
            "author": {
                "id": "rec_cie05krjtojbm41fv2q0"
            },
            "id": "rec_cie05v3jtojbm41fv2tg",
            "likes": 15,
            "title": "On the performance impact of REPLICA IDENTITY FULL in Postgres"
        },
        {
            "author": {
                "id": "rec_cie05krjtojbm41fv2q0"
            },
            "id": "rec_cii1kajjtoj0t82ae3ag",
            "likes": 6,
            "title": "Semantic or keyword search for finding ChatGPT context. Who searched it better?"
        }
    ]
}
```

We are performing "1" (get the authors) + "n" (get the authors's posts) requests. This is inconvenient and also quite inefficient, since the number of requests depends on the number of user records.

There are workarounds depending on the data set and the amount of code we are willing to write, like getting _all_ the authors and _all_ the posts, or using the `IN` operator and then processing the response in the app. But it would be better if our API would help us getting exactly what we want.

# Navigate links backwards

Since the relationship is already defined by the `link` column, it’s a matter of providing a good API experience to get this data more easily. We have introduced [column expressions](/docs/concepts/data-model#links-and-relations) in the query endpoint so the `columns` field is no longer restricted to a list of column names. Now we are able to provide a JSON object to better define the projection we want.

To better understand this concept, let's improve on the previous example to showcase the benefits of navigating relationships in reverse using column expressions:

```json
// Request
POST /db/blogs:main/tables/users/query
{
  "columns": [
      "*",
      {
          "name": "<-posts.author",
          "columns": ["title"]
      }
  ]
}
```

In this request we are asking for all the fields in the _Users_ table (`*`) plus a column expression. The expression consists of a structure with two fields:

- `name`: When using the `<-` prefix, it signifies that we are navigating in reverse along the link defined by the `author` column in the _posts_ table. This reverse navigation establishes a one-to-many relationship between the linked records.

- `columns`: The `columns` field defines the projection to be applied to the table on the opposite side of this relationship. It specifies which fields from the related table should be included in the query result.

What we get back is a list of post data nested in every author record. The default name for the nested list is `postsauthor` (i.e. table name + link name):

```json
// Response (xata fields have been omitted for clarity)
{
    "records": [
        {
            "id": "rec_cie05krjtojbm41fv2q0",
            "name": "Tudor Golubenco",
            "postsauthor": {
                "records": [
                    {
                        "id": "rec_cie05srjtojbm41fv2t0",
                        "title": "Postgres schema changes are still a PITA"
                    },
                    {
                        "id": "rec_cie05v3jtojbm41fv2tg",
                        "title": "On the performance impact of REPLICA IDENTITY FULL in Postgres"
                    },
                    {
                        "id": "rec_cii1kajjtoj0t82ae3ag",
                        "title": "Semantic or keyword search for finding ChatGPT context. Who searched it better?"
                    }
                ]
            }
        },
        {
            "id": "rec_cie05ljjtojbm41fv2qg",
            "name": "Joan Edwards",
            "postsauthor": {
                "records": [
                    {
                        "id": "rec_cie060jjtojbm41fv2u0",
                        "title": "Introducing the new Xata regions: Sydney & Frankfurt"
                    }
                ]
            }
        },
        {
            "id": "rec_cii1ki3jtoj0t82ae3b0",
            "name": "Alex Francoeur",
            "postsauthor": {
                "records": [
                    {
                        "id": "rec_cii1kpbjtoj0t82ae3c0",
                        "title": "End-to-end preview deployment workflows with Xata and Vercel"
                    },
                    {
                        "id": "rec_cii1kjjjtoj0t82ae3bg",
                        "title": "The next era of databases are serverless, adaptive, and collaborative"
                    },
                    {
                        "id": "rec_cii1l1rjtoj0t82ae3cg",
                        "title": "Modern database workflows with GitHub, Vercel, Netlify, and Xata"
                    }
                ]
            }
        }
    ]
}
```

Using this syntax we are able to avoid the N + 1 problem - getting all the data we want using a single request and, therefore, avoiding any unnecessary roundtrips and repetitive code.

More fields are available to configure the projection further: `as`, `sort`, `limit`, `offset`. The same request can be modified like the following:

```json
// Request
POST /db/blogs:main/tables/users/query
{
  "columns": [
      "*",
      {
          "name": "<-posts.author",
          "as": "posts", // Field is returned as `posts`
          "columns": ["title"],
          "sort": [      // Return the nested records in this order
						{"title": "desc"}
          ],
          "limit": 1,    // Limit the amount of nested records to 1
          "offset": 1    // Skip first nested record
      }
  ]
}

// Response (xata fields have been omitted for clarity)
{
    "records": [
        {
            "id": "rec_cie05krjtojbm41fv2q0",
            "name": "Tudor Golubenco",
            "posts": {
                "records": [
                    {
                        "id": "rec_cii1kajjtoj0t82ae3ag",
                        "title": "Semantic or keyword search for finding ChatGPT context. Who searched it better?"
                    }
                ]
            }
        },
        {
            "id": "rec_cie05ljjtojbm41fv2qg",
            "name": "Joan Edwards",
            "posts": {
                "records": [
                    {
                        "id": "rec_cie060jjtojbm41fv2u0",
                        "title": "Introducing the new Xata regions: Sydney & Frankfurt"
                    }
                ]
            }
        },
        {
            "id": "rec_cii1ki3jtoj0t82ae3b0",
            "name": "Alex Francoeur",
            "posts": {
                "records": [
                    {
                        "id": "rec_cii1kjjjtoj0t82ae3bg",
                        "title": "The next era of databases are serverless, adaptive, and collaborative"
                    }
                ]
            }
        }
    ]
}
```

For the moment, sorting options and classical pagination (limit and offset) are available for the reverse link querying. In the future, we will add support for filtering and cursor pagination. Similarly, we plan to add support for following multiple reverse links transitively. Nevertheless, we think that the majority of use cases are solved by the current functionality already.

# Conclusion

The new Xata querying syntax makes it possible to traverse the N:1 relationships backwards and therefore solves the N + 1 problem in a single round-trip.

If you have feedback or questions, you can reach out to us on [Discord](https://xata.io/discord) or [X | Twitter](https://twitter.com/xata).
